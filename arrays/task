0. Зададим целочисленный массив (Int) (для фиксированных значений) вроде такого:

import Data.Array

arI :: Array (Int,Int) Int
arI = array ((1,1),(2,3)) [((1,1),8), ((1,2),11), ((1,3),4),
((2,1),3), ((2,2),2), ((2,3),4)]


1. Суммировать элементы массива массива, используя elems, foldl1 и sum :)

2. Суммировать элементы массива, используя indices и прямой доступ к элементам.

3. Вывести список значений элементов, у которых сумма индексов равна значению, т.е.

arI ! (i,j) = i+j

4. Заменить значения элементов, у которых сумма индексов равна значению, на 77 (с помощью инкрементального обновления, функции (//)).

5. Для исходного массива координат точек

например, listArray (1,5) ([((-5.23),4.2),(2.456,13.234),(11241,211.2),((-1),0),(8.3,3.8)]::[(Double,Double)])

вычислить длину пути ломанной, соединяющей точки в порядке возрастания нумерации в массиве.

6. Дан массив измерений

a = listArray (1,10) ([1.3,1.2,1.9,1.25,1.4,0.1,1.2,1.32,1.23,1.5]::[Double])

Вывести массив значений, усреднённых по соседним величинам, т.е.

b!i = (a!(i-1) + a!i + a!(i+1))/3

для внутренних значений и с ближайшим соседом -- для крайних.




Софья, пора уже искать более высокоуровневые решения!! Иначе, весь Хаскелл пройдёт мимо (((

№1 
sum arI
№2
sum [arI ! i | i <- indices arI]

№3
[arI ! i | i <- indices arr, arI!i == fst i + snd i]

№5 считает длину ломанной неправильно =((

№6  вычисляет новый список неправильно
